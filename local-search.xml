<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图的连通性</title>
    <link href="/2022/10/17/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/"/>
    <url>/2022/10/17/%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="图的连通性"><a href="#图的连通性" class="headerlink" title="图的连通性"></a>图的连通性</h1><h2 id="tarjan求割点"><a href="#tarjan求割点" class="headerlink" title="tarjan求割点"></a>tarjan求割点</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> head[maxn];<br>struct node&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">to</span>,val,next;<br>&#125;;<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>node edge[maxn];<br><span class="hljs-type">void</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> val)&#123;<br>    edge[tot].<span class="hljs-keyword">to</span>=v;<br>    edge[tot].val=val;<br>    edge[tot].next=head[u];<br>    head[u]=tot++;<br>&#125;<br><span class="hljs-type">int</span> dfn[maxn];<br><span class="hljs-type">int</span> low[maxn];<br><span class="hljs-type">int</span> boo[maxn];<br><span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> root;<br><span class="hljs-type">void</span> tarjan(<span class="hljs-type">int</span> x)&#123;<br>    dfn[x]=low[x]=++cnt;<br>    <span class="hljs-type">int</span> flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];i!=<span class="hljs-number">-1</span>;i=edge[i].next)&#123;<br>        <span class="hljs-type">int</span> y=edge[i].<span class="hljs-keyword">to</span>;<br>        <span class="hljs-keyword">if</span>(!dfn[y])&#123;<br>            tarjan(y);<br>            low[x]=min(low[x],low[y]);//子树最小low<br>            <span class="hljs-keyword">if</span>(low[y]&gt;=dfn[x])&#123;<br>                flag++;<br>                <span class="hljs-keyword">if</span>(x!=root&amp;&amp;flag&gt;<span class="hljs-number">1</span>)boo[x]=<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> low[x]=min(low[x],dfn[y]);<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> n;<br><span class="hljs-type">void</span> solve()&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-keyword">if</span>(!dfn[i])&#123;<br>            tarjan(i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>网络流</title>
    <link href="/2022/10/14/%E7%BD%91%E7%BB%9C%E6%B5%81/"/>
    <url>/2022/10/14/%E7%BD%91%E7%BB%9C%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h1 id="最大流"><a href="#最大流" class="headerlink" title="最大流"></a>最大流</h1><h2 id="dinic"><a href="#dinic" class="headerlink" title="dinic"></a>dinic</h2><h3 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>const <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> d[maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt;vec[maxn];<br><span class="hljs-type">int</span> head[maxn];<br><span class="hljs-type">int</span> nxt[maxn];<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>struct node&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">to</span>,val;<br>&#125;;<br>node edge[<span class="hljs-number">2</span>*maxn];<br><span class="hljs-type">void</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> z)&#123;<br>    edge[tot].<span class="hljs-keyword">to</span>=v,edge[tot].val=z,nxt[tot]=head[u],head[u]=tot++;<br>    edge[tot].<span class="hljs-keyword">to</span>=u,edge[tot].val=<span class="hljs-number">0</span>,nxt[tot]=head[v],head[v]=tot++;<br>&#125;<br><span class="hljs-type">bool</span> MakeLevel(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)&#123;<br>    memset(d,<span class="hljs-number">0</span>,sizeof(d));<br>    d[s]=<span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.push(s);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        <span class="hljs-type">int</span> now = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(now==t)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];~i;i=nxt[i])&#123;<br>            <span class="hljs-keyword">if</span>(edge[i].val&amp;&amp;!d[edge[i].<span class="hljs-keyword">to</span>])&#123;<br>                q.push(edge[i].<span class="hljs-keyword">to</span>);<br>                d[i]=d[now]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> dfs(<span class="hljs-type">int</span> x ,<span class="hljs-type">int</span> flow,<span class="hljs-type">int</span> t)&#123;<br>    <span class="hljs-keyword">if</span>(x==t)<span class="hljs-keyword">return</span> flow;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=nxt[i])&#123;<br>        <span class="hljs-keyword">if</span>((edge[i].val!=<span class="hljs-number">0</span>)&amp;&amp;(d[edge[i].<span class="hljs-keyword">to</span>]==d[x]+<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-type">int</span> tmp=dfs(edge[i].<span class="hljs-keyword">to</span>,min(flow-sum,edge[i].val),t);<br>            edge[i].val-=tmp;<br>            edge[i^<span class="hljs-number">1</span>].val+=tmp;<br>            sum+=tmp;<br>            <span class="hljs-keyword">if</span>(sum==flow)<span class="hljs-keyword">return</span> sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> s,t;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(MakeLevel(s,t))&#123;<br>        ans+=dfs(s,<span class="hljs-number">0x3f3f3f3f</span>,t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="ISAP"><a href="#ISAP" class="headerlink" title="ISAP"></a>ISAP</h2><h3 id="板子-1"><a href="#板子-1" class="headerlink" title="板子"></a>板子</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-meta">#include &lt;bits/stdc++.h&gt;</span><br><span class="hljs-keyword">using</span> namespace std;<br>const <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e5</span>+<span class="hljs-number">3</span>;<br><span class="hljs-type">int</span> d[maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt;vec[maxn];<br><span class="hljs-type">int</span> head[maxn];<br><span class="hljs-type">int</span> nxt[maxn];<br><span class="hljs-type">int</span> tot=<span class="hljs-number">0</span>;<br>struct node&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">to</span>,val;<br>&#125;;<br>node edge[<span class="hljs-number">2</span>*maxn];<br><span class="hljs-type">void</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">int</span> u,<span class="hljs-type">int</span> v,<span class="hljs-type">int</span> z)&#123;<br>    edge[tot].<span class="hljs-keyword">to</span>=v,edge[tot].val=z,nxt[tot]=head[u],head[u]=tot++;<br>    edge[tot].<span class="hljs-keyword">to</span>=u,edge[tot].val=<span class="hljs-number">0</span>,nxt[tot]=head[v],head[v]=tot++;<br>&#125;<br><span class="hljs-type">bool</span> MakeLevel(<span class="hljs-type">int</span> s,<span class="hljs-type">int</span> t)&#123;<br>    memset(d,<span class="hljs-number">0</span>,sizeof(d));<br>    d[s]=<span class="hljs-number">1</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt;q;<br>    q.push(s);<br>    <span class="hljs-keyword">while</span>(!q.empty())&#123;<br>        <span class="hljs-type">int</span> now = q.front();<br>        q.pop();<br>        <span class="hljs-keyword">if</span>(now==t)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[now];~i;i=nxt[i])&#123;<br>            <span class="hljs-keyword">if</span>(edge[i].val&amp;&amp;!d[edge[i].<span class="hljs-keyword">to</span>])&#123;<br>                q.push(edge[i].<span class="hljs-keyword">to</span>);<br>                d[i]=d[now]+<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-type">int</span> S,M;<br><span class="hljs-type">int</span> cntd[maxn];<br><span class="hljs-type">int</span> dfs(<span class="hljs-type">int</span> x ,<span class="hljs-type">int</span> flow,<span class="hljs-type">int</span> t)&#123;<br>    <span class="hljs-keyword">if</span>(x==t)<span class="hljs-keyword">return</span> flow;<br>    <span class="hljs-type">int</span> sum=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=head[x];~i;i=nxt[i])&#123;<br>        <span class="hljs-keyword">if</span>(edge[i].val&amp;&amp;(d[x]==d[edge[i].<span class="hljs-keyword">to</span>]+<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-type">int</span> tmp=dfs(i,min(edge[i].val,flow-sum),t);<br>            edge[i].val-=tmp;<br>            edge[i^<span class="hljs-number">1</span>].val+=tmp;<br>            sum+=tmp;<br>            <span class="hljs-keyword">if</span>(sum==flow)<span class="hljs-keyword">return</span> sum;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(d[S]&gt;=M)<span class="hljs-keyword">return</span> sum;<br>    cntd[d[x]]<span class="hljs-comment">--;</span><br>    <span class="hljs-keyword">if</span>(!cntd[d[x]])d[S]=M;<br>    d[x]++;<br>    cntd[d[x]]++;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><span class="hljs-type">int</span> main() &#123;<br>    <span class="hljs-type">int</span> s,t;<br>    <span class="hljs-type">int</span> ans=<span class="hljs-number">0</span>;<br>    S=s;<br>    MakeLevel(s,t);<br>    <span class="hljs-keyword">while</span>(d[S]&lt;M)&#123;<br>        ans+=dfs(s,<span class="hljs-number">0x3f3f3f3f</span>,t);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实验一 游戏项目和开源项目的调研</title>
    <link href="/2022/09/16/%E5%AE%9E%E9%AA%8C%E4%B8%80%20%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B0%83%E7%A0%94/"/>
    <url>/2022/09/16/%E5%AE%9E%E9%AA%8C%E4%B8%80%20%E6%B8%B8%E6%88%8F%E9%A1%B9%E7%9B%AE%E5%92%8C%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E7%9A%84%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h1 id="实验一-游戏项目和开源项目的调研"><a href="#实验一-游戏项目和开源项目的调研" class="headerlink" title="实验一 游戏项目和开源项目的调研"></a>实验一 游戏项目和开源项目的调研</h1><p>小组成员：潘浩霖  202031101581  刘通  202031101542</p><h2 id="Pacman（吃豆人游戏）"><a href="#Pacman（吃豆人游戏）" class="headerlink" title="Pacman（吃豆人游戏）"></a>Pacman（吃豆人游戏）</h2><p><a href="https://passer-by.com/pacman/">游戏演示</a></p><h3 id="一-游戏简介"><a href="#一-游戏简介" class="headerlink" title="一  游戏简介"></a>一  游戏简介</h3><p>《吃豆人》（Pac-Man）是一部由同名街机游戏移植至Atari 2600平台的游戏，最早由南梦宫公司于1980年在街机上推出，后由雅达利公司于1982年3月中旬发售Atari 2600版。 《吃豆人》算是比较经典的游戏了，笔者小时候并没有接触过这个游戏，最初的接触还是在迪士尼动画电影《无敌破坏王》中认识到的。这个项目使用HTML和js很好的还原了这个游戏，其中作者内置了12个关卡，游戏还是十分流畅的。</p><h3 id="二-功能介绍"><a href="#二-功能介绍" class="headerlink" title="二  功能介绍"></a>二  功能介绍</h3><p>地图绘制</p><p> 玩家控制</p><p> NPC根据玩家坐标实时自动寻径</p><p> 吃豆积分系统</p><p> 能量豆功能</p><p> 多关卡(共12关)</p><h2 id="基于hexo框架的博客搭建项目"><a href="#基于hexo框架的博客搭建项目" class="headerlink" title="基于hexo框架的博客搭建项目"></a>基于hexo框架的博客搭建项目</h2><h3 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h3><p>Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。</p><p><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166332816216782428625496%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166332816216782428625496&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82729029-null-null.142%5Ev47%5Enew_blog_pos_by_title,201%5Ev3%5Econtrol&utm_term=hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2&spm=1018.2226.3001.4187">项目搭建博客</a></p><p><a href="https://github.com/Salo103/Salo103.github.io">项目搭建成功后个人GitHub库</a></p><h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><p>发布文章</p><p>文章设置发布时间</p><p>文章分类</p><p>自定义博客主题</p><h3 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h3><p>node.js</p><p>hexo</p><p>hexo与GitHub的连接</p>]]></content>
    
    
    <categories>
      
      <category>软件项目管理实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>实验二-软件项目管理的直观感受</title>
    <link href="/2022/09/11/%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97/"/>
    <url>/2022/09/11/%E5%AE%9E%E9%AA%8C%E4%BA%8C-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%B4%E8%A7%82%E6%84%9F%E5%8F%97/</url>
    
    <content type="html"><![CDATA[<p>小组成员：潘浩霖  202031101581  刘通  202031101542</p><p><img src="https://img-community.csdnimg.cn/images/c60e5dbd71cb412193617b2c60fdfe70.png?x-oss-process=image/auto-orient,1" alt="1"></p><h2 id="范围管理"><a href="#范围管理" class="headerlink" title="范围管理"></a>范围管理</h2><p>在我们开发作业管理系统范围分析的时候,我们首先确定作业管理系统的工作和管理范围,从老师的需求和学生的需求角度切入,以作业管理为核心,大致上囊括了老师批改,打分,学生提交,查阅等功能.尽量覆盖平时我们所会遇到的关于作业的问题.确定我们所必须要完成的任务.</p><h2 id="进度管理"><a href="#进度管理" class="headerlink" title="进度管理"></a>进度管理</h2><p>为了高效利用时间来开发我们的项目,我们制定了含若干项目进程时间点的计划.对于项目需求分析,子模块的功能开发与代码实现,数据库的设计与构造,代码的合并与数据库的连接,系统测试和验收等具体按时间安排与跟进进度,及时灵活调整进度的安排.</p><h2 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h2><p>对于软件的开发成本估算与分析,我们采用的是mysql与idea这种免费的开发环境,许多漏洞也有我们查阅资料补足,预计是无成本费用</p><h2 id="质量管理"><a href="#质量管理" class="headerlink" title="质量管理"></a>质量管理</h2><p>规划质量管理,实施质量保证,控制质量.对于每个子模块功能开发时,如老师的批阅作业功能开发,我们需要保证老师能正确批阅对应学生所提交的作业,确保开发时功能实现高质量.在开发的整个过程都注意质量保障.</p><h2 id="人力资源管理"><a href="#人力资源管理" class="headerlink" title="人力资源管理"></a>人力资源管理</h2><p>规划人力资源管理；组建项目团队；建设项目团队；管理项目团队。对于我们项目开发团队,我们将人力资源按模块分配, 将管理员模块,教师模块,学生模块分配的不同的成员,再细分每个模块的具体功能给对应模块下的成员.</p><h2 id="沟通管理"><a href="#沟通管理" class="headerlink" title="沟通管理"></a>沟通管理</h2><p>规划沟通管理；管理沟通；控制沟通。我们充分利用了软件工程实验课的时间来面对面沟通开发时所遇到的问题,也可以用如微信, qq等网上沟通的平台来交流与沟通项目进度.</p><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>规划风险管理；识别风险；实施定性风险分析；实施定量风险分析；规划风险应对；控制风险。在开发项目中,我们遇到的风险主要来自于技术实现上的进度跟不上,我们需要及时通过查阅资料和询问老师来降低该风险带来的影响.</p><h2 id="集成管理"><a href="#集成管理" class="headerlink" title="集成管理"></a>集成管理</h2><p>在项目生命周期中协调所有其他项目管理知识领域所涉及的过程，确保项目所有组成要素在恰当的时间、正确的地方、合适的人物结合在一起，以恰当地完成项目我们开发项目中对总体的集成管理仍有不足,许多计划与实现还有很大进步区间.</p>]]></content>
    
    
    <categories>
      
      <category>软件项目管理实验</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几何板子</title>
    <link href="/2022/09/03/%E5%87%A0%E4%BD%95%E6%9D%BF%E5%AD%90/"/>
    <url>/2022/09/03/%E5%87%A0%E4%BD%95%E6%9D%BF%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h1 id="几何板子"><a href="#几何板子" class="headerlink" title="几何板子"></a>几何板子</h1><h2 id="判断是否是凸多边形"><a href="#判断是否是凸多边形" class="headerlink" title="判断是否是凸多边形"></a>判断是否是凸多边形</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> endl <span class="hljs-string">&quot;\n&quot;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-type">int</span> x[<span class="hljs-number">10</span>];<br><span class="hljs-type">int</span> y[<span class="hljs-number">10</span>];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">4</span>;i++)cin&gt;&gt;x[i]&gt;&gt;y[i];<br>    x[<span class="hljs-number">5</span>]=x[<span class="hljs-number">1</span>];<br>    y[<span class="hljs-number">5</span>]=y[<span class="hljs-number">1</span>];<br>    x[<span class="hljs-number">6</span>]=x[<span class="hljs-number">2</span>];<br>    y[<span class="hljs-number">6</span>]=y[<span class="hljs-number">2</span>];<br><span class="hljs-comment">//    x[5]=x[1];</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>;i&lt;=<span class="hljs-number">6</span>;i++)&#123;<br>        <span class="hljs-type">int</span> tmp=(x[i]-x[i<span class="hljs-number">-2</span>])*(y[i<span class="hljs-number">-1</span>]-y[i<span class="hljs-number">-2</span>])-(x[i<span class="hljs-number">-1</span>]-x[i<span class="hljs-number">-2</span>])*(y[i]-y[i<span class="hljs-number">-2</span>]);<br>        <span class="hljs-keyword">if</span>(tmp&gt;<span class="hljs-number">0</span>)&#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;No&quot;</span>;<br>        <span class="hljs-keyword">return</span> ;<br>    &#125;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&quot;Yes&quot;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    ios::sync_with_stdio(false);</span><br><span class="hljs-comment">//    cin.tie(0), cout.tie(0);</span><br>    <span class="hljs-type">int</span> T=<span class="hljs-number">1</span>;<br><span class="hljs-comment">//    cin &gt;&gt; T;</span><br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>树链剖分</title>
    <link href="/2022/08/08/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
    <url>/2022/08/08/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h1 id="树链剖分"><a href="#树链剖分" class="headerlink" title="树链剖分"></a>树链剖分</h1><h2 id="板子"><a href="#板子" class="headerlink" title="板子"></a>板子</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int sz<span class="hljs-comment">[maxn]</span>;<br>int fa<span class="hljs-comment">[maxn]</span>;<br>int son<span class="hljs-comment">[maxn]</span>;<br>int depth<span class="hljs-comment">[maxn]</span>;<br>vector&lt;int&gt;vec<span class="hljs-comment">[maxn]</span>;<br>void dfs1(int st,int f,int deep)&#123;<br>    sz<span class="hljs-comment">[st]</span>=1;<br>    fa<span class="hljs-comment">[st]</span>=f;<br>    depth<span class="hljs-comment">[st]</span>=deep;<br>    for(auto i:vec<span class="hljs-comment">[st]</span>)&#123;<br>        if(i!=f)&#123;<br>            dfs1(i,st,deep+1);<br>            sz<span class="hljs-comment">[st]</span>+=sz<span class="hljs-comment">[i]</span>;<br>            if(son<span class="hljs-comment">[st]</span>==0||sz<span class="hljs-comment">[son<span class="hljs-comment">[st]</span>]</span>&lt;sz<span class="hljs-comment">[i]</span>)&#123;<br>                son<span class="hljs-comment">[st]</span>=i;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>int id<span class="hljs-comment">[maxn]</span>;<br>int idx<span class="hljs-comment">[maxn]</span>;<br>int dfn=0;<br>int top<span class="hljs-comment">[maxn]</span>;<br>int R<span class="hljs-comment">[maxn]</span>;<br>void dfs2(int st,int f)&#123;<br>    id<span class="hljs-comment">[st]</span>=++dfn;<br>    idx<span class="hljs-comment">[st]</span>=dfn;<br>    top<span class="hljs-comment">[st]</span>=f;<br>    if(son<span class="hljs-comment">[st]</span>)dfs2(son<span class="hljs-comment">[st]</span>,f);<br>    for(auto i:vec<span class="hljs-comment">[st]</span>)&#123;<br>        if(i!=son<span class="hljs-comment">[st]</span>&amp;&amp;i!=fa<span class="hljs-comment">[i]</span>)&#123;<br>            dfs2(i,i);<br>        &#125;<br>    &#125;<br>&#125;<br>int Lca(int x,int y)&#123;<br>    while(top<span class="hljs-comment">[x]</span>!=top<span class="hljs-comment">[y]</span>)&#123;<br>        if(depth<span class="hljs-comment">[x]</span>&lt;depth<span class="hljs-comment">[y]</span>)swap(x,y);<br>        x=fa<span class="hljs-comment">[top<span class="hljs-comment">[x]</span>]</span>;<br>    &#125;<br>    if(depth<span class="hljs-comment">[x]</span>&lt;depth<span class="hljs-comment">[y]</span>)swap(x,y);<br>    return y;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Eezie-and-Pie"><a href="#Eezie-and-Pie" class="headerlink" title="Eezie and Pie"></a>Eezie and Pie</h2><p><a href="https://ac.nowcoder.com/acm/contest/33191/B">题源</a></p><p>题意 :给定一颗树,每个端点都有对应的能量,每个端点都可以消耗1能量来向上一个节点送pie,询问每个端点最多能被送几个pie</p><p>解析 :最朴素的想法肯定是对每一个端点都消耗完能量来向父节点送派,遇到的问题为如果每个点都往上爬它对应能量数量的点,那复杂度将为O(n2),那如果可以将每个点往上爬更新父节点的时间代价降为log级,就可以用最朴素的想法实现该题.那只要树链剖分后维护一个当前所剩能量power,往上跳点时比较power和当前所在点now与链首top[now]的距离(可以用id[now]和id[top[now]]来O(1)实现),据题意模拟,因为相当于每次会对一段区间进行+1处理,所以用前缀和处理区间操作即可.具体实现上要注意根节点的处理,在处理时要注意1号节点往上更新时会更新到0号节点,要将更新0号节点的操作变为更新1号节点.还要注意每个点对自身送pie是不需要消耗能量的,初始可以将pre[1]设成1(前缀和后相当于每个点答案设成了1),在树剖模拟时就不用处理自身的点了(因为自身点不需要代价,因此模拟可能会有点多要考虑的).</p><p>代码: </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs prolog">#include &lt;bits/stdc++.h&gt;<br>#include&lt;stack&gt;<br>#include&lt;vector&gt;<br>using namespace std;<br>const int maxn = <span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<br>int sz[maxn];<br>int son[maxn];<br>int fa[maxn];<br>vector&lt;int&gt;vec[maxn];<br>void dfs1(int st,int f)&#123;<br>    sz[st]=<span class="hljs-number">1</span>;<br>    fa[st]=f;<br>    for(auto i:vec[st])&#123;<br>        if(i!=f)&#123;<br>            dfs1(i,st);<br>            sz[st]+=sz[i];<br>            if(son[st]==<span class="hljs-number">0</span>||sz[son[st]]&lt;sz[i])son[st]=i;<br>        &#125;                           <br>    &#125;<br>&#125;<br>int dfn=<span class="hljs-number">0</span>;<br>int id[maxn];<br>int idx[maxn];<br>int top[maxn];<br>void dfs2(int st,int f)&#123;<br>    id[st]=++dfn;<br>    idx[dfn]=st;<br>    top[st]=f;<br>    if(son[st])dfs2(son[st],f);<br>    for(auto i:vec[st])&#123;<br>        if(i!=fa[st]&amp;&amp;i!=son[st])&#123;<br>            dfs2(i,i);<br>        &#125;<br>    &#125;<br>&#125;<br>int d[maxn];<br>int pre[maxn];<br>void <span class="hljs-symbol">Lca</span>(int x)&#123;<br>    int power=d[x];<br>    int now=fa[x];<br>//     pre[x]++;<br>    while(now!=<span class="hljs-number">0</span>&amp;&amp;power&gt;<span class="hljs-number">0</span>)&#123;<br>        if(power&gt;=id[now]-id[top[now]]+<span class="hljs-number">1</span>)&#123;<br>            power-=(id[now]-id[top[now]]+<span class="hljs-number">1</span>);<br>//              cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;id[top[now]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;id[now]&lt;&lt;<span class="hljs-string">&quot; X&quot;</span>&lt;&lt;endl;<br>            pre[id[now]+<span class="hljs-number">1</span>]--;<br>            pre[id[top[now]]]++;<br>        &#125;<br>        else&#123;<br>//             cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;id[now-power+<span class="hljs-number">1</span>]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;id[now]&lt;&lt;<span class="hljs-string">&quot; Y&quot;</span>&lt;&lt;endl;<br>            pre[id[now]-power+<span class="hljs-number">1</span>]++;<br>            pre[id[now]+<span class="hljs-number">1</span>]--;<br>            break;<br>        &#125;<br>        now=fa[top[now]];<br>    &#125;<br>&#125;<br>vector&lt;int&gt;as;<br>void solve() &#123;<br>    memset(pre,<span class="hljs-number">0</span>,sizeof(pre));<br>    int n;<br>    cin&gt;&gt;n;<br>    as.clear();<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)vec[i].clear();<br>    for(int i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        int t1,t2;<br>        cin&gt;&gt;t1&gt;&gt;t2;<br>        vec[t1].push_back(t2);<br>        vec[t2].push_back(t1);<br>    &#125;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)cin&gt;&gt;d[i];<br>    dfs1(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    dfs2(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>);<br>    top[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    fa[<span class="hljs-number">1</span>]=<span class="hljs-number">0</span>;<br>    pre[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    id[<span class="hljs-number">0</span>]=<span class="hljs-number">1</span>;<br>    id[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        <span class="hljs-symbol">Lca</span>(i);<br>    &#125;<br>    for(int i=<span class="hljs-number">2</span>;i&lt;=n;i++)&#123;<br>        pre[i]+=pre[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    for(int i=<span class="hljs-number">1</span>;i&lt;n;i++)&#123;<br>        cout&lt;&lt;pre[id[i]]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout&lt;&lt;pre[id[n]]&lt;&lt;endl;<br>&#125;<br><br>int main() &#123;<br>    ios::sync_with_stdio(false);<br>    cin.tie(<span class="hljs-number">0</span>), cout.tie(<span class="hljs-number">0</span>);<br>    int <span class="hljs-symbol">T</span> = <span class="hljs-number">1</span>;<br>    while (<span class="hljs-symbol">T</span>--) &#123;<br>        solve();<br>    &#125;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Codeforces  补题</title>
    <link href="/2022/08/03/Codeforces%E8%A1%A5%E9%A2%98/"/>
    <url>/2022/08/03/Codeforces%E8%A1%A5%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Codeforces-补题"><a href="#Codeforces-补题" class="headerlink" title="Codeforces  补题"></a>Codeforces  补题</h1><h2 id="Color-with-Occurrences"><a href="#Color-with-Occurrences" class="headerlink" title="Color with Occurrences"></a>Color with Occurrences</h2><p>题源 : <a href="https://codeforces.com/contest/1714/problem/D">Color with Occurrences</a></p><p>题目大意 : 给一个原字符串,再给若干个长度小于原串的子串,询问最少由几个子串拼成原串(有拼不出来的情况)</p><p>思路 : 题目数据范围给得小,往暴力求解的方向想,从原串起点出发,尽可能选能覆盖最多原串尚未覆盖的子串,对于原串每一个点,都求一次选择以该点开头的子串最多覆盖到原串的哪里,记一个该点选子串所能覆盖原串最远覆盖距离tr;定义一个原串最远可覆盖距离r;原串已被覆盖距离cover.当枚举的该点</p><p>坐标大于已被覆盖距离cover时,即需要在前面枚举的点中提取一个可行的最远覆盖距离来更新已覆盖距离,每个点枚举tr时,r更新为r与tr的最大值,即r为前面枚举的点所能覆盖的最长距离,当更新cover时,如果前面点所能覆盖的最远距离r都要小于等于 该点坐标i(即没办法将已覆盖距离往后延长,后面的点没办法用子串覆盖到),那就是无法构造原串,输出-1; 若可往后覆盖,那将cover更新为前面点所能覆盖到的最长距离r,只有cover更新时才需要记录答案,在更新最长覆盖距离r时可以记下当前题干所需的所选子串种类,当前点坐标,那cover更新时就可以记下</p><p>代码 :</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-comment">//#define int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">1e3</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>&#125;<br><br>string a[maxn];<br>vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; vec;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vec.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> sz = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> cover = <span class="hljs-number">-1</span>;                <span class="hljs-type">int</span> tloc = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-number">-1</span>, tidx = <span class="hljs-number">-1</span>; i &lt; sz &amp;&amp; r &lt; sz; i++) &#123;<br>        <span class="hljs-type">int</span> ttidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> tr = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (i + a[j].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt; sz &amp;&amp; s.<span class="hljs-built_in">substr</span>(i, a[j].<span class="hljs-built_in">size</span>()) == a[j] &amp;&amp; i + a[j].<span class="hljs-built_in">size</span>() &gt; tr) &#123;<br>                ttidx = j;<br>                tr = i + a[j].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ttidx != <span class="hljs-number">-1</span> &amp;&amp; tr &gt; r) &#123;<br>            r = tr;<br>            tidx=ttidx;<br>            tloc=i+<span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//            vec.push_back(&#123;tidx, i + 1&#125;);</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (i &gt; cover) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt; r)&#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-1&quot;</span> &lt;&lt; endl;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            vec.<span class="hljs-built_in">push_back</span>(&#123;tidx,tloc&#125;);<br>            cover=r;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; vec.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i:vec) &#123;<br>        cout &lt;&lt; i.first &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; i.second &lt;&lt; endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int32_t</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><hr><h2 id="Build-Permutation"><a href="#Build-Permutation" class="headerlink" title="Build Permutation"></a>Build Permutation</h2><p><a href="https://codeforces.com/contest/1713/problem/C">题源</a></p><p>题意: 给定一个n,要求对于0到n-1来说,构造一个同样时0到n-1的一个排列,对应位相加为完全平方数</p><p>解析: 那对于n-1来说,大于n-1且距离最近的完全平方数与n-1的差值一定小于n-1,从大到小没有操作过的数进行操作,当前数x找到最近的完全平方数i后,x+(i-x)就为完全平方数,x往前数i-x个数也可变为完全平方数i(i-x+x),再往未操作的数(i-x-1)开始进行该操作</p><p>代码: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stack&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxn = <span class="hljs-number">2e6</span>+<span class="hljs-number">5</span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> tc=<span class="hljs-built_in">sqrt</span>(x);<br>    <span class="hljs-keyword">return</span> tc*tc==x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(x&lt;=<span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> ;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=x;;i++)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Check</span>(i))&#123;<br>            <span class="hljs-type">int</span> t=(i-x);<br>            <span class="hljs-built_in">solve</span>(t<span class="hljs-number">-1</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=x;j&gt;=t;j--)&#123;<br>                cout&lt;&lt;j&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br><span class="hljs-comment">//                t--;</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> T = <span class="hljs-number">1</span>;<br>    cin&gt;&gt;T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        <span class="hljs-type">int</span> n;<br>        cin&gt;&gt;n;<br>        <span class="hljs-built_in">solve</span>(n<span class="hljs-number">-1</span>);<br>        cout&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>补题</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二分图算法整理</title>
    <link href="/2022/07/30/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <url>/2022/07/30/%E4%BA%8C%E5%88%86%E5%9B%BE%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二分图算法整理"><a href="#二分图算法整理" class="headerlink" title="二分图算法整理"></a>二分图算法整理</h1><h2 id="二分图黑白染色"><a href="#二分图黑白染色" class="headerlink" title="二分图黑白染色"></a>二分图黑白染色</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> col[maxn];<br>vector&lt;<span class="hljs-type">int</span>&gt;vec[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st,<span class="hljs-type">int</span> fa,<span class="hljs-type">int</span> ty)</span></span>&#123;<br>    col[st]=ty;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:vec[st])&#123;<br>        <span class="hljs-keyword">if</span>(i!=fa)&#123;<br>            <span class="hljs-keyword">if</span>(!col[i])&#123;<br>                <span class="hljs-built_in">dfs</span>(i,st,ty%<span class="hljs-number">2</span>+<span class="hljs-number">1</span>);<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(col[i]==ty)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>按黑白双色深搜即可</p><hr><h2 id="二分图最大匹配-增广路算法"><a href="#二分图最大匹配-增广路算法" class="headerlink" title="二分图最大匹配 增广路算法"></a>二分图最大匹配 增广路算法</h2><h3 id="增广路算法代码"><a href="#增广路算法代码" class="headerlink" title="增广路算法代码"></a>增广路算法代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">vector&lt;<span class="hljs-type">int</span>&gt;vec[maxn];<br><span class="hljs-type">int</span> link[maxn];<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> st)</span></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:vec[st])&#123;<br>        <span class="hljs-keyword">if</span>(!vis[i])&#123;<br>            <span class="hljs-keyword">if</span>(!link[i]||<span class="hljs-built_in">dfs</span>(i))&#123;<br>                link[i]=st;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="增广路算法的解析"><a href="#增广路算法的解析" class="headerlink" title="增广路算法的解析"></a>增广路算法的解析</h3><p>主函数调用时对每一个点都调用一次连边的深搜,深搜一次代价为o(m),复杂度为O(n*m)</p><p>最小点覆盖等于最大匹配数</p><p>算法大意是在找增广路，一个点在向他所连边的点进行一次连边请求，如果连边的点没有被连过边，那直接将该点与连边点相连；如果连边的点已被其他点所连，那会让那个点去连其它没有连过的点，如果连接成功，则那个点和新进的点相连，初始点和连边点相连，在每一次连边都是这样处理，最后能有连接成功的就新进了一个点，如果访问了所有点都不行，那该点就连接失败</p><h2 id="二分图最优匹配-KM算法"><a href="#二分图最优匹配-KM算法" class="headerlink" title="二分图最优匹配  ＫＭ算法"></a>二分图最优匹配  ＫＭ算法</h2>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
